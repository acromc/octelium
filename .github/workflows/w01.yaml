name: Cleanup Untagged Org Images

on:
  workflow_dispatch:
    inputs:
      organization:
        description: 'The GitHub Organization name'
        required: true
        type: string
      package_names:
        description: 'Space-separated list of package names to clean (e.g., backend-api frontend-app)'
        required: true
        type: string
      days_old:
        description: 'Delete images older than (days)'
        required: true
        default: '90'
        type: string
      dry_run:
        description: 'Dry Run? (Check to list images without deleting)'
        required: true
        default: true
        type: boolean

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read # Basic scope, but we use the PAT for org-wide access

    steps:
      - name: Validate and Setup
        run: |
          if [ -z "${{ secrets.ORG_PACKAGE_TOKEN }}" ]; then
            echo "::error::Secret ORG_PACKAGE_TOKEN is missing. Please add a PAT with delete:packages scope."
            exit 1
          fi

      - name: Process Images
        env:
          GH_TOKEN: ${{ secrets.ORG_PACKAGE_TOKEN }}
          ORG: ${{ inputs.organization }}
          PACKAGES: ${{ inputs.package_names }}
          DAYS: ${{ inputs.days_old }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          echo "## ðŸ§¹ Cleanup Report" >> $GITHUB_STEP_SUMMARY
          echo "| Package | Image ID | Created At | Status |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :--- | :--- | :--- |" >> $GITHUB_STEP_SUMMARY

          # Calculate cutoff timestamp
          CUTOFF_DATE=$(date -d "$DAYS days ago" +%Y-%m-%d)
          CUTOFF_TS=$(date -d "$CUTOFF_DATE" +%s)
          
          echo "Targeting images older than: $CUTOFF_DATE"

          # Iterate through provided package names
          for PKG in $PACKAGES; do
            echo "Processing package: $PKG..."
            
            # Fetch versions (pagination might be needed for huge lists, fetching first 100 here)
            # We filter for 'container' type.
            versions=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/orgs/$ORG/packages/container/$PKG/versions?per_page=100")

            # Loop through versions using jq to filter
            # Logic: Select items where metadata.container.tags is empty AND created_at < cutoff
            
            echo "$versions" | jq -r --argjson cutoff "$CUTOFF_TS" '.[] | select((.metadata.container.tags | length) == 0) | select((.created_at | fromdateiso8601) < $cutoff) | "\(.id) \(.created_at)"' | \
            while read -r version_id created_at; do
              
              if [ "$DRY_RUN" = "true" ]; then
                echo "DRY RUN: Would delete $PKG version $version_id (Created: $created_at)"
                echo "| $PKG | $version_id | $created_at | ðŸŸ¡ Dry Run (Skipped) |" >> $GITHUB_STEP_SUMMARY
              else
                echo "DELETING: $PKG version $version_id (Created: $created_at)"
                
                # Execute Delete
                gh api \
                  --method DELETE \
                  -H "Accept: application/vnd.github+json" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "/orgs/$ORG/packages/container/$PKG/versions/$version_id"
                
                if [ $? -eq 0 ]; then
                  echo "| $PKG | $version_id | $created_at | âœ… Deleted |" >> $GITHUB_STEP_SUMMARY
                else
                  echo "| $PKG | $version_id | $created_at | âŒ Error |" >> $GITHUB_STEP_SUMMARY
                fi
              fi
            done
          done
